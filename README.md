# goit-algo-fp

Final project for Basic Algorithms and Data Structures

## Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

Для реалізації однозв'язного списку (приклад реалізації можна взяти з конспекту) необхідно:

- написати функцію, яка реалізує реверсування однозв'язного списку, змінюючи посилання між вузлами;
- розробити алгоритм сортування для однозв'язного списку, наприклад, сортування вставками або злиттям;
- написати функцію, що об'єднує два відсортовані однозв'язні списки в один відсортований список.

## Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії

Необхідно написати програму на Python, яка використовує рекурсію для створення фрактала “дерево Піфагора”. Програма має візуалізувати фрактал “дерево Піфагора”, і користувач повинен мати можливість вказати рівень рекурсії.

## Завдання 3. Дерева, алгоритм Дейкстри

Розробіть алгоритм Дейкстри для знаходження найкоротших шляхів у зваженому графі, використовуючи бінарну купу. Завдання включає створення графа, використання піраміди для оптимізації вибору вершин та обчислення найкоротших шляхів від початкової вершини до всіх інших.

## Завдання 4. Візуалізація піраміди

Суть завдання полягає у створенні дерева із купи.
Наданий код виконує побудову бінарних дерев. Виконайте аналіз коду, щоб зрозуміти, як він працює.

## Завдання 5. Візуалізація обходу бінарного дерева

Використовуючи код із завдання 4 для побудови бінарного дерева, необхідно створити програму на Python, яка візуалізує обходи дерева: у глибину та в ширину.

Вона повинна відображати кожен крок у вузлах з різними кольорами, використовуючи 16-систему RGB. Кольори вузлів мають змінюватися від темних до світлих відтінків, залежно від послідовності обходу. Кожен вузол при його відвідуванні має отримувати унікальний колір, який візуально відображає порядок обходу.

## Завдання 6. Жадібні алгоритми та динамічне програмування

Необхідно написати програму на Python, яка використовує два підходи — жадібний алгоритм та алгоритм динамічного програмування для розв’язання задачі вибору їжі з найбільшою сумарною калорійністю в межах обмеженого бюджету.

Кожен вид їжі має вказану вартість і калорійність. Дані про їжу представлені у вигляді словника, де ключ — назва страви, а значення — це словник з вартістю та калорійністю.

Розробіть функцію greedy_algorithm жадібного алгоритму, яка вибирає страви, максимізуючи співвідношення калорій до вартості, не перевищуючи заданий бюджет.

Для реалізації алгоритму динамічного програмування створіть функцію dynamic_programming, яка обчислює оптимальний набір страв для максимізації калорійності при заданому бюджеті.

## Завдання 7. Використання методу Монте-Карло

Необхідно написати програму на Python, яка імітує велику кількість кидків кубиків, обчислює суми чисел, які випадають на кубиках, і визначає ймовірність кожної можливої суми.

Створіть симуляцію, де два кубики кидаються велику кількість разів. Для кожного кидка визначте суму чисел, які випали на обох кубиках. Підрахуйте, скільки разів кожна можлива сума (від 2 до 12) з’являється у процесі симуляції. Використовуючи ці дані, обчисліть імовірність кожної суми.

На основі проведених імітацій створіть таблицю або графік, який відображає ймовірності кожної суми, виявлені за допомогою методу Монте-Карло.

Порівняйте отримані за допомогою методу Монте-Карло результати з аналітичними розрахунками, наведеними в таблиці вище.

## Висновки:

1) Надана реалізація однозв'язного списку, яка має наступні переваги перед іншими статичними структурами даних:
    - Динамічний розмір: Однозв'язний список може легко збільшуватися або зменшуватися в розмірі під час виконання програми, оскільки пам'ять виділяється динамічно.
    - Ефективна вставка/видалення: Додавання або видалення елементів на початку або в середині списку є дуже ефективним (O(1) або O(n) відповідно), оскільки потрібно лише змінити кілька посилань.
    - Гнучкість: Може використовуватися для реалізації інших структур даних, таких як стеки, черги та хеш-таблиці.
    - Економія пам'яті: Немає необхідності виділяти безперервний блок пам'яті, що може бути корисним у системах з обмеженою пам'яттю або при роботі з дуже великими списками.
    - Простота реалізації: Порівняно з деякими іншими структурами даних, такими як двозв'язні списки або масиви з динамічним розміром, однозв'язний список має відносно просту реалізацію.

2) Надана реалізація візуалізації одного з математичних фракталів (дерево Піфагора) за допомогою бібліотеки matplotlib. Вона використовує принцип рекурсії для створення дерева, де кожен листок представляється прямокутником, а кожен внутрішній прямокутник 


3) Надана реалізація генарції рандомізованого графа а також алгоритм Дейкстри для пошуку найкоротшого шляху в графі, використовуючи піраміду (heap) для оптимізації вибору вершин та обчислення найкоротших шляхів від початкової вершини до всіх інших.

4) Надана реалізація алгоритма для побудови дерева із рандомізованої купи (heap) за допомогою бібліотеки matplotlib. 

5) Надана реалізація обходу дерева в глибину та в ширину за допомогою бібліотеки matplotlib.

6) Надана реалізація жадібного алгоритму та алгоритму динамічного програмування для розв'язання задачі вибору їжі з найбільшою сумарною калорійністю в межах обмеженого бюджету.

    - Результати показують, що жадібний алгоритм швидше виконується, але не завжди дає оптимальний результат.
    Алгоритм динамічного програмування завжди дає оптимальний результат, але виконується довше.

    - Жадібний алгоритм обирає найкращий варіант на кожному кроці, не враховуючи загального оптимального варіанту.
    У такому випадку жадібний алгоритм постійно вибирає лише варіант 'Салат Мімоза з куркою' не залежно від залишків бюджету.

    - Алгоритм динамічного програмування обирає найкращий варіант на кожному кроці, враховуючи загальний оптимальний варіант. У такому випадку крім 'Салат Мімоза з куркою' вибирається також 'Зрази картопляні з м'ясом', що дає оптимальний результат у випадках, коли залишок бюджету достатній для обміну на цей варіант.

7) Надана реалізація алгоритму Монте-Карло для обчислення ймовірності кожної можливої суми, яка випадає на кубиках. Результати дают наступні висновки:

    - Метод Монте-Карло при великій кількості симуляцій (1 000 000) дає результати, які практично збігаються з аналітичними ймовірностями.

    - Невеликі відхилення пояснюються випадковим характером моделювання і зменшуються зі збільшенням кількості симуляцій.

    - Модель підтверджує коректність реалізації як генерації випадкових чисел, так і аналітичних формул.

    - Для подібних дискретних випадків з відомими розподілами метод Монте-Карло є ефективним інструментом для перевірки теоретичних результатів.